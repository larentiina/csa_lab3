# Лабораторная работа №3. Отчёт

Кузенина Валерия Николаевна, P3232

`alg | acc | harv | hw | tick | struct | stream | port | pstr | prob1 |`

Базовый вариант (без усложнения)
## Синтаксис
``` ebnf
<program> ::= { <statement> }

<statement> ::= "if" <cond-expr> <statement> |
                "if" <cond-expr> <statement> "else" <statement> |
                "while" <cond-expr> <statement> |
                "{" { <statement> } "}" |
                <expr> ";" |
                <input-expr> ";" |
                <output-expr> ";" |
                <declaration> |
                <variable_assignment> |
                ";"

<declaration> ::= type <id> "=" <expr>

<variable_assignment> ::= <id> "=" <expr>

<cond-expr> ::= "(" <expr> ( "==" | "<" | ">" ) <expr> ")"

<type> ::= "int" | "string"

<input-expr> ::= "input" "(" <id> ")" |  "input_char" "(" <id> ")"

<output-expr> ::= "print" ( <id> | <string> ) | "print_char" ( <id> | <letter> )

<expr> ::= <id> |
           <digit> |
           <string> |
           <expr> "%" <expr> |
           <expr> "+" <expr> |
           <expr> "-" <expr>

<id> ::= <letter>

<string> ::= <letter> | <string> <letter>

<letter> ::= [a-zA-Z]

<digit> ::= "0" | "1" | ... | "9"
```
### Особенности
- У переменных глобальная область видимости
- Статическая строгая типизация
- Поддерживаемые типы: `string`, `int`
  - `int` - числовой тип, используется всегда по значению. Может принимать значение любого числа, помещающегося в 1 слово.
  - `string` - строковый тип. Память под строки выделяется статически. Строки immutable. При присваивании переменной типа string новой строки в памяти меняется указатель на данную переменную.
- Поддерживаются математические операции: `+`, `-`,`%`
- Все операторы левоасоциативные, кроме операторов сравнения: `<`, `>`,`==` - они имеют высший приоритет
- Сигнатуры всех методов одинаковы: `(int,int) -> int`
- Поддерживаются функции: `print(string| var) , print_char(var), input(var), input_char(var)':
  - print_char(var) и  input_char(var) - выводят и считывают только один символ
  - print(string| var) и input(var) - выводят и считывают всю строку целиком


## Организация памяти
### Память инструкций
Память для хранения инструкций выполнения программы. Реализуется списком объектов класса Opcode
Инструкция состоит из названия команды, аргумента (опционально), вида адресации (опционально)
Виды адресации представлены в классе AddressMode
Размер машинного слова не определен.
### Память данных
Размер машинного слова 16 бит.
В памяти данных хранятся статические данные - числа и строки.
Число занимает одну ячейку памяти.
Строки распределяются по одному символу в одну ячейку памяти, в начале строки - её длина.
Вывод данных из памяти осуществляется в data register по адресу в data address
Ввод данных в память осуществляется и аккумулятора по сигналу oe по адресу в data address
### Модель данных
Обращение к переменной всегда осуществляется через прямую адресацию. 
Временные константы не сохраняются в статическую память и обращение к ним проиходит через непосредственную адресацию

## Система команд
### Набор инструкций

| Opcode | ARG   | Кол-во тактов | Описание                                                    |
|:-----|:----    |:--------------|:------------------------------------------------------------|
| ST   | +   | 2                 | сохранить значение в указанной ячейке из acc                  |
| LD   | +   | 2                 | загрузить значение в acc                   |
| CMP  | +   | 1               | установить флаги z и n по операции acc - arg                           |
| HLT  | -   | 0               | остановка                                |
| ADD  | +   | 2               | сложить значение из аккумулятора со значением, переданным в аргументе          |
| SUB  | +   | 2               | вычесть из аккумулятора значение, переданное в аргументе |
| DIV  | +`  | 1               | посчитать модуль числа от деления аккумулятора на значение, переданное в аргументе                                     |
| OUT  | -   | 2               | вывести значение из аккумулятора на устройство вывода                          |
|  IN  | -   | 0               | ввести значение в аккумулятор с устройства ввода                                                  |
|  JNZ | +   | 0               | переход если флаг z не установлен                                                  |
|  JZ  | +   | 0               | переход если флаг z установлен                                                  |
|  JN  | +   | 0               | переход если флаг n установлен                                                  |
|  JLE | +   | 0               | переход если флаг z установлен или n установлен (переход если меньше либо равно)                                                 |
|  JGE | +   | 0               | переход если флаг z установлен или n не установлен (переход если больше либо равно)                                                 |
|  JMP | +   | 1               | безусловный переход                                         |

Реализовано 3 вида адресации операнда:
- IMMEDIATE -  аргумент содержит данные. 
- DIRECT - операнд указывает на ячейку памяти, содержащую данные. 
- INDIRECT - операнд содержит адрес памяти, по которому находится фактический адрес данных.

## Транслятор
Реализован в [translator](./translator.py)
Интерфейс командной строки: `.\translator.py <input_file> <target_file>`
Этапы трансляции:
- Код разбивается на токены в классе `Lexer`. У токена есть - текст и тип токена. Типы токенов представлены в классе `TokensName`. В классе `Lexer` метод `lex()` - выполняется лексический анализ входной строки, тип токена определяется согласно совпадению с регулярным выражением из списка `token_exprs`. Если не удается найти соответствие для символа, выводится сообщение об ошибке.
- В классе `Parser `строится AST дерево в соответствии с BNF. У каждого узла дерева - объект класса Node есть ссылки на 3 дочерних узла и в зависимости от типа родительского узла используется нужное их количество. Парсер реализован по LL принципу - анализирует токены слева направо. Метод `statement()` - рекурсивный метод анализирующий типы токенов и исходя из этого создаёт узлы. Метод `cond_expression()` - генерирует узлы для условный выражений. Метод `kind_of_node()` - создаёт узел для токенов, которые являются константами или названием переменных.
- В классе `Compiler` генерируется машинный код согласно AST дереву последовательно компилируя его узлы. В этом классе происходит заполнение статической памяти, находящейся в классе `MemoryManager`. Метод `compile()` - основной рекурсивный метод, в котором проиходит анализ типов узлов и генерация на этом основании послеовательности машинных инструкций.
- После этапа трансляции в `<target_file>`записывается последовательность машинных инструкций, которая пойдет в память инструкций в процессор, а в файл `data_section.txt` записывается заполненная статическая память, которая пойдет в память данных в процессоре.

### Пример

## Модель процессора
Реализован в [machine](./machine.py)
Интерфейс командной строки: `.\machine <input_code_file> <input_text>
### Схема
![data_path.svg](./model/data_path.svg)
![cu.svg](./model/cu.svg)

Control Unit:
- Моделирование на уровне тактов
- Instruction Decoder - декодировщик инструкций, отправляет в память данные в регистры `DA`/`DR` и необходимые сигналы в `DAata Path`
Сигналы (обрабатываются за 1 такт, реализованы в виде методов класса):
- latch_acc - защелкнуть выбранное значение в `ACC`
- latch_data_reg - защелкнуть выбранное значение в `DR`
- latch_data_address - защелкнуть выбранное значение в `DA`
- signal_wr_to_memory
- signal_latch_program_counter- защелкнуть выбранное значение в `PC`
Флаги:

Z (Zero) - отражает наличие нулевого значения в ACC
N (Negative) - отражает наличие отрицательного значения в ACC

Особенности работы модели:
- Команды, которые имеют аргумент проходят цикл выборки операнда - `operand_fetch` в связи с несколькими видами адресации
- Остановка симуляции осуществляется при помощи исключений:
 - StopIteration = при достижении HLT инструкции
 - MachineException = при возникновении рантайм-ошибок (деление на 0, слишком большая программа, слишком долгое исполнение и т.д.)
 - EOFException = при ошибке Buffer is empty
